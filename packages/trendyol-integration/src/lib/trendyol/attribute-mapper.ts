import { createClient } from '@/lib/supabase/server'
import { getTrendyolClient } from './api-client'
import { 
  TrendyolCategory, 
  TrendyolAttribute, 
  TrendyolApiCategoryResponse,
  TrendyolApiAttributeResponse,
  SyncResult,
  TrendyolApiProduct,
  TrendyolApiCredentials
} from '@/types/trendyol'

export class AttributeMapper {
  private credentials: TrendyolApiCredentials | null = null

  constructor(credentials?: TrendyolApiCredentials) {
    this.credentials = credentials || null
  }

  /**
   * Trendyol'dan t√ºm kategorileri √ßeker ve veritabanƒ±na kaydeder
   */
  async syncCategories(): Promise<SyncResult> {
    try {
      const client = await this.getTrendyolClient()
      if (!client) {
        return { success: false, error: 'Trendyol client ba≈ülatƒ±lamadƒ±' }
      }

      console.log('üìã Trendyol kategorileri √ßekiliyor...')
      // Trendyol kategorilerini √ßek
      const categories = await client.getCategories()
      
      console.log('üìä API Response:', {
        type: typeof categories,
        isArray: Array.isArray(categories),
        length: categories?.length || 0,
        sample: categories ? categories.slice(0, 2) : null
      })
      
      if (!categories || categories.length === 0) {
        console.log('‚ùå Kategoriler bo≈ü veya undefined:', categories)
        return { success: false, error: 'Kategori listesi alƒ±namadƒ±' }
      }

      const supabase = await createClient()
      let syncedCount = 0
      let errors: string[] = []

      // Kategorileri recursive olarak i≈üle
      const processCategories = async (categoryList: TrendyolApiCategoryResponse[], parentId?: number) => {
        for (const category of categoryList) {
          try {
            // Veritabanƒ±na kaydet
            const { error } = await supabase
              .from('trendyol_categories')
              .upsert({
                trendyol_category_id: category.id,
                category_name: category.name,
                parent_category_id: parentId || null,
                is_active: true
              }, {
                onConflict: 'trendyol_category_id'
              })

            if (error) {
              errors.push(`Kategori ${category.name} kaydedilemedi: ${error.message}`)
            } else {
              syncedCount++
            }

            // Alt kategoriler varsa i≈üle
            if (category.subCategories && category.subCategories.length > 0) {
              await processCategories(category.subCategories, category.id)
            }

          } catch (error) {
            errors.push(`Kategori ${category.name} i≈ülenirken hata: ${error instanceof Error ? error.message : 'Bilinmeyen hata'}`)
          }
        }
      }

      await processCategories(categories)

      // Sync zamanƒ±nƒ± g√ºncelle
      await supabase
        .from('trendyol_settings')
        .update({ last_category_sync: new Date().toISOString() })
        .eq('is_active', true)

      if (errors.length > 0) {
        return {
          success: false,
          error: `${syncedCount} kategori senkronize edildi, ${errors.length} hata olu≈ütu`,
          data: { syncedCount, errors }
        }
      }

      return {
        success: true,
        message: `${syncedCount} kategori ba≈üarƒ±yla senkronize edildi`,
        data: { syncedCount }
      }

    } catch (error) {
      console.error('Kategori senkronizasyon hatasƒ±:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Kategori senkronizasyonu ba≈üarƒ±sƒ±z'
      }
    }
  }

  /**
   * Belirli bir kategorinin zorunlu alanlarƒ±nƒ± √ßeker ve kaydeder
   */
  async syncCategoryAttributes(categoryId: number): Promise<SyncResult> {
    try {
      const client = await this.getTrendyolClient()
      if (!client) {
        return { success: false, error: 'Trendyol client ba≈ülatƒ±lamadƒ±' }
      }

      // Kategorinin attribute'larƒ±nƒ± √ßek
      const attributes = await client.getCategoryAttributes(categoryId)
      
      if (!attributes || attributes.length === 0) {
        return { 
          success: true, 
          message: `Kategori ${categoryId} i√ßin zorunlu alan bulunamadƒ±` 
        }
      }

      const supabase = await createClient()
      let syncedCount = 0
      let errors: string[] = []

      for (const attributeResponse of attributes) {
        try {
          const attribute = attributeResponse.attribute

          // Allowed values hazƒ±rla
          const allowedValues = attribute.attributeValues?.map(v => v.name) || []

          // Veritabanƒ±na kaydet
          const { error } = await supabase
            .from('trendyol_attributes')
            .upsert({
              trendyol_category_id: categoryId,
              attribute_name: attribute.name,
              attribute_type: this.detectAttributeType(attribute),
              is_required: attribute.required,
              allowed_values: allowedValues.length > 0 ? allowedValues : null
            }, {
              onConflict: 'trendyol_category_id,attribute_name'
            })

          if (error) {
            errors.push(`Attribute ${attribute.name} kaydedilemedi: ${error.message}`)
          } else {
            syncedCount++
          }

        } catch (error) {
          errors.push(`Attribute i≈ülenirken hata: ${error instanceof Error ? error.message : 'Bilinmeyen hata'}`)
        }
      }

      if (errors.length > 0) {
        return {
          success: false,
          error: `${syncedCount} attribute senkronize edildi, ${errors.length} hata olu≈ütu`,
          data: { syncedCount, errors }
        }
      }

      return {
        success: true,
        message: `${syncedCount} attribute ba≈üarƒ±yla senkronize edildi`,
        data: { syncedCount }
      }

    } catch (error) {
      console.error('Attribute senkronizasyon hatasƒ±:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Attribute senkronizasyonu ba≈üarƒ±sƒ±z'
      }
    }
  }

  /**
   * T√ºm aktif kategoriler i√ßin attribute'larƒ± senkronize eder
   */
  async syncAllCategoryAttributes(): Promise<SyncResult> {
    try {
      const supabase = await createClient()
      
      // Aktif kategorileri al
      const { data: categories, error } = await supabase
        .from('trendyol_categories')
        .select('trendyol_category_id, category_name')
        .eq('is_active', true)

      if (error) {
        return { success: false, error: `Kategoriler alƒ±namadƒ±: ${error.message}` }
      }

      if (!categories || categories.length === 0) {
        return { success: false, error: 'Aktif kategori bulunamadƒ±' }
      }

      let totalSynced = 0
      let totalErrors: string[] = []

      // Her kategori i√ßin attribute'larƒ± senkronize et
      for (const category of categories) {
        try {
          const result = await this.syncCategoryAttributes(category.trendyol_category_id)
          
          if (result.success) {
            totalSynced += result.data?.syncedCount || 0
          } else {
            totalErrors.push(`${category.category_name}: ${result.error}`)
          }

          // Rate limiting i√ßin bekleme
          await new Promise(resolve => setTimeout(resolve, 1500))

        } catch (error) {
          totalErrors.push(`${category.category_name}: ${error instanceof Error ? error.message : 'Bilinmeyen hata'}`)
        }
      }

      if (totalErrors.length > 0) {
        return {
          success: false,
          error: `${totalSynced} attribute senkronize edildi, ${totalErrors.length} kategoride hata olu≈ütu`,
          data: { totalSynced, errors: totalErrors }
        }
      }

      return {
        success: true,
        message: `${totalSynced} attribute ${categories.length} kategoriden ba≈üarƒ±yla senkronize edildi`,
        data: { totalSynced, categoryCount: categories.length }
      }

    } catch (error) {
      console.error('Toplu attribute senkronizasyon hatasƒ±:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Toplu attribute senkronizasyonu ba≈üarƒ±sƒ±z'
      }
    }
  }

  /**
   * Yerel √ºr√ºn√º Trendyol formatƒ±na d√∂n√º≈üt√ºr√ºr
   */
  async mapProductToTrendyol(productId: string): Promise<{ success: boolean; data?: TrendyolApiProduct; error?: string }> {
    try {
      const supabase = await createClient()

      // √úr√ºn bilgilerini al
      const { data: product, error: productError } = await supabase
        .from('products')
        .select(`
          *,
          categories (
            id,
            name,
            trendyol_categories (
              trendyol_category_id,
              category_name
            )
          )
        `)
        .eq('id', productId)
        .single()

      if (productError || !product) {
        return { success: false, error: '√úr√ºn bulunamadƒ±' }
      }

      // Kategori mapping kontrol√º
      const trendyolCategory = product.categories?.trendyol_categories?.[0]
      if (!trendyolCategory) {
        return { 
          success: false, 
          error: '√úr√ºn kategorisi Trendyol ile e≈üle≈ütirilmemi≈ü' 
        }
      }

      // Barcode kontrol√º
      if (!product.barcode) {
        return { 
          success: false, 
          error: '√úr√ºn barkodu eksik' 
        }
      }

      // Zorunlu alanlarƒ± kontrol et
      const validationResult = await this.validateProductAttributes(
        product, 
        trendyolCategory.trendyol_category_id
      )

      if (!validationResult.success) {
        return { 
          success: false, 
          error: `Zorunlu alanlar eksik: ${validationResult.error}` 
        }
      }

      // Trendyol product objesi olu≈ütur
      const trendyolProduct: TrendyolApiProduct = {
        barcode: product.barcode,
        title: product.name,
        description: product.description || product.short_description || '',
        categoryId: trendyolCategory.trendyol_category_id,
        quantity: product.stock_quantity || 0,
        listPrice: Number(product.compare_price || product.price),
        salePrice: Number(product.price),
        images: product.images?.map(url => ({ url })) || [],
        attributes: validationResult.data?.attributes || []
      }

      return { success: true, data: trendyolProduct }

    } catch (error) {
      console.error('√úr√ºn mapping hatasƒ±:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : '√úr√ºn mapping ba≈üarƒ±sƒ±z'
      }
    }
  }

  /**
   * √úr√ºn√ºn zorunlu alanlarƒ±nƒ± validate eder
   */
  private async validateProductAttributes(product: any, categoryId: number): Promise<{
    success: boolean;
    error?: string;
    data?: { attributes: Array<{ attributeId: number; attributeValueId: number; customAttributeValue?: string }> };
  }> {
    try {
      const supabase = await createClient()

      // Kategorinin zorunlu alanlarƒ±nƒ± al
      const { data: attributes, error } = await supabase
        .from('trendyol_attributes')
        .select('*')
        .eq('trendyol_category_id', categoryId)
        .eq('is_required', true)

      if (error) {
        return { success: false, error: `Zorunlu alanlar alƒ±namadƒ±: ${error.message}` }
      }

      if (!attributes || attributes.length === 0) {
        return { success: true, data: { attributes: [] } }
      }

      const missingAttributes: string[] = []
      const mappedAttributes: Array<{ 
        attributeId: number; 
        attributeValueId: number; 
        customAttributeValue?: string 
      }> = []

      for (const attr of attributes) {
        // Burada ger√ßek mapping logic'i olacak
        // ≈ûimdilik placeholder deƒüerler veriyoruz
        switch (attr.attribute_name.toLowerCase()) {
          case 'marka':
          case 'brand':
            if (!product.brand) {
              missingAttributes.push('Marka')
            } else {
              // Marka ID'si mapping'i gerekecek
              mappedAttributes.push({
                attributeId: 1, // Placeholder
                attributeValueId: 1, // Placeholder  
                customAttributeValue: product.brand
              })
            }
            break

          case 'renk':
          case 'color':
            // Renk attribute'u varsa ekle
            break

          case 'beden':
          case 'size':
            // Beden attribute'u varsa ekle
            break

          default:
            // Diƒüer zorunlu alanlar i√ßin generic handling
            break
        }
      }

      if (missingAttributes.length > 0) {
        return { 
          success: false, 
          error: missingAttributes.join(', ') 
        }
      }

      return { 
        success: true, 
        data: { attributes: mappedAttributes } 
      }

    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Validation hatasƒ±' 
      }
    }
  }

  /**
   * Attribute tipini tespit eder
   */
  private detectAttributeType(attribute: any): 'text' | 'number' | 'select' | 'multiselect' {
    if (attribute.attributeValues && attribute.attributeValues.length > 0) {
      return 'select'
    }
    
    if (attribute.allowCustom) {
      return 'text'
    }

    // Default olarak text
    return 'text'
  }

  /**
   * Trendyol client'ƒ± al
   */
  private async getTrendyolClient() {
    if (this.credentials) {
      return getTrendyolClient(this.credentials)
    }

    // Settings'den al
    const supabase = await createClient()
    const { data: settings, error } = await supabase
      .from('trendyol_settings')
      .select('supplier_id, api_key, api_secret, mock_mode, test_mode')
      .eq('is_active', true)
      .single()

    if (error || !settings) {
      throw new Error('Aktif Trendyol ayarlarƒ± bulunamadƒ±')
    }

    return getTrendyolClient({
      supplierId: settings.supplier_id,
      apiKey: settings.api_key,
      apiSecret: settings.api_secret
    }, settings.mock_mode, settings.test_mode)
  }

  /**
   * Kategori e≈üle≈ütirmesi yapar
   */
  async mapLocalCategory(localCategoryId: string, trendyolCategoryId: number): Promise<SyncResult> {
    try {
      const supabase = await createClient()

      const { error } = await supabase
        .from('trendyol_categories')
        .update({ local_category_id: localCategoryId })
        .eq('trendyol_category_id', trendyolCategoryId)

      if (error) {
        return { 
          success: false, 
          error: `Kategori e≈üle≈ütirmesi ba≈üarƒ±sƒ±z: ${error.message}` 
        }
      }

      return { 
        success: true, 
        message: 'Kategori e≈üle≈ütirmesi ba≈üarƒ±yla tamamlandƒ±' 
      }

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Kategori e≈üle≈ütirme hatasƒ±'
      }
    }
  }

  /**
   * Credentials'ƒ± g√ºnceller
   */
  updateCredentials(credentials: TrendyolApiCredentials): void {
    this.credentials = credentials
  }
} 